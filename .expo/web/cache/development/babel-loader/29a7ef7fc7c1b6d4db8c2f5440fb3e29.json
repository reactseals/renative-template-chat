{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.attachListeners = attachListeners;\nexports.addNode = addNode;\nexports.removeNode = removeNode;\nexports.terminateResponder = terminateResponder;\nexports.getResponderNode = getResponderNode;\n\nvar _ExecutionEnvironment = require(\"fbjs/lib/ExecutionEnvironment\");\n\nvar _createResponderEvent = _interopRequireDefault(require(\"./createResponderEvent\"));\n\nvar _ResponderEventTypes = require(\"./ResponderEventTypes\");\n\nvar _utils = require(\"./utils\");\n\nvar _ResponderTouchHistoryStore = _interopRequireDefault(require(\"./ResponderTouchHistoryStore\"));\n\nfunction _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar emptyObject = {};\n\n\nvar startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {\n  bubbles: true }];\n\nvar moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {\n  bubbles: true }];\n\nvar scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {\n  bubbles: false }];\n\nvar shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration };\n\nvar emptyResponder = {\n  id: null,\n  idPath: null,\n  node: null };\n\nvar responderListenersMap = new Map();\nvar isEmulatingMouseEvents = false;\nvar trackedTouchCount = 0;\nvar currentResponder = {\n  id: null,\n  node: null,\n  idPath: null };\n\n\nfunction changeCurrentResponder(responder) {\n  currentResponder = responder;\n}\n\nfunction getResponderConfig(id) {\n  var config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nfunction eventListener(domEvent) {\n  var eventType = domEvent.type;\n  var eventTarget = domEvent.target;\n\n\n\n\n\n\n\n\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  }\n\n\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  }\n\n\n  if (\n  eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents ||\n  eventType === 'mousemove' && trackedTouchCount < 1) {\n    return;\n  }\n\n\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n\n    return;\n  }\n\n  var isStartEvent = (0, _ResponderEventTypes.isStartish)(eventType) && (0, _utils.isPrimaryPointerDown)(domEvent);\n  var isMoveEvent = (0, _ResponderEventTypes.isMoveish)(eventType);\n  var isEndEvent = (0, _ResponderEventTypes.isEndish)(eventType);\n  var isScrollEvent = (0, _ResponderEventTypes.isScroll)(eventType);\n  var isSelectionChangeEvent = (0, _ResponderEventTypes.isSelectionChange)(eventType);\n  var responderEvent = (0, _createResponderEvent.default)(domEvent);\n\n\n\n\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n\n    _ResponderTouchHistoryStore.default.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n\n\n\n\n\n  var eventPaths = (0, _utils.getResponderPaths)(domEvent);\n  var wasNegotiated = false;\n  var wantsResponder;\n\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\n\n\n    var currentResponderIdPath = currentResponder.idPath;\n    var eventIdPath = eventPaths.idPath;\n\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      var lowestCommonAncestor = (0, _utils.getLowestCommonAncestor)(currentResponderIdPath, eventIdPath);\n\n      if (lowestCommonAncestor != null) {\n        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);\n\n        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index) };\n\n      } else {\n        eventPaths = null;\n      }\n    }\n\n    if (eventPaths != null) {\n\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n\n      if (wantsResponder != null) {\n\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  }\n\n\n  if (currentResponder.id != null && currentResponder.node != null) {\n    var _currentResponder = currentResponder,\n    id = _currentResponder.id,\n    node = _currentResponder.node;\n\n    var _getResponderConfig = getResponderConfig(id),\n    onResponderStart = _getResponderConfig.onResponderStart,\n    onResponderMove = _getResponderConfig.onResponderMove,\n    onResponderEnd = _getResponderConfig.onResponderEnd,\n    onResponderRelease = _getResponderConfig.onResponderRelease,\n    onResponderTerminate = _getResponderConfig.onResponderTerminate,\n    onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;\n\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node;\n\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        onResponderStart(responderEvent);\n      }\n    } else\n      if (isMoveEvent) {\n        if (onResponderMove != null) {\n          onResponderMove(responderEvent);\n        }\n      } else {\n        var isTerminateEvent = (0, _ResponderEventTypes.isCancelish)(eventType) ||\n        eventType === 'contextmenu' ||\n        eventType === 'blur' && eventTarget === window ||\n        eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node ||\n        isScrollEvent && trackedTouchCount === 0 ||\n        isScrollEvent && eventTarget.contains(node) && eventTarget !== node ||\n        isSelectionChangeEvent && (0, _utils.hasValidSelection)(domEvent);\n        var isReleaseEvent = isEndEvent && !isTerminateEvent && !(0, _utils.hasTargetTouches)(node, domEvent.touches);\n\n        if (isEndEvent) {\n          if (onResponderEnd != null) {\n            onResponderEnd(responderEvent);\n          }\n        }\n\n\n        if (isReleaseEvent) {\n          if (onResponderRelease != null) {\n            onResponderRelease(responderEvent);\n          }\n\n          changeCurrentResponder(emptyResponder);\n        }\n\n\n        if (isTerminateEvent) {\n          var shouldTerminate = true;\n\n          if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {\n            if (wasNegotiated ||\n            onResponderTerminationRequest != null && onResponderTerminationRequest(responderEvent) === false) {\n              shouldTerminate = false;\n            }\n          }\n\n          if (shouldTerminate) {\n            if (onResponderTerminate != null) {\n              onResponderTerminate(responderEvent);\n            }\n\n            changeCurrentResponder(emptyResponder);\n            isEmulatingMouseEvents = false;\n            trackedTouchCount = 0;\n          }\n        }\n      }\n  }\n}\n\n\n\n\n\n\n\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type];\n\n  if (shouldSetCallbacks != null) {\n    var idPath = eventPaths.idPath,\n    nodePath = eventPaths.nodePath;\n    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    var bubbles = shouldSetCallbacks[2].bubbles;\n\n    var check = function check(id, node, callbackName) {\n      var config = getResponderConfig(id);\n      var shouldSetCallback = config[callbackName];\n\n      if (shouldSetCallback != null) {\n        if (shouldSetCallback(responderEvent) === true) {\n          return {\n            id: id,\n            node: node,\n            idPath: idPath };\n\n        }\n      }\n    };\n\n\n    for (var i = idPath.length - 1; i >= 0; i--) {\n      var id = idPath[i];\n      var node = nodePath[i];\n      var result = check(id, node, shouldSetCallbackCaptureName);\n\n      if (result != null) {\n        return result;\n      }\n\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    }\n\n\n    if (bubbles) {\n      for (var _i = 0; _i < idPath.length; _i++) {\n        var _id = idPath[_i];\n        var _node = nodePath[_i];\n\n        var _result = check(_id, _node, shouldSetCallbackBubbleName);\n\n        if (_result != null) {\n          return _result;\n        }\n\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      var _id2 = idPath[0];\n      var _node2 = nodePath[0];\n      var target = domEvent.target;\n\n      if (target === _node2) {\n        return check(_id2, _node2, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\n\n\n\n\n\nfunction attemptTransfer(responderEvent, wantsResponder) {\n  var _currentResponder2 = currentResponder,\n  currentId = _currentResponder2.id,\n  currentNode = _currentResponder2.node;\n  var id = wantsResponder.id,\n  node = wantsResponder.node;\n\n  var _getResponderConfig2 = getResponderConfig(id),\n  onResponderGrant = _getResponderConfig2.onResponderGrant,\n  onResponderReject = _getResponderConfig2.onResponderReject;\n\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node;\n\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n\n    changeCurrentResponder(wantsResponder);\n  } else\n    {\n      var _getResponderConfig3 = getResponderConfig(currentId),\n      onResponderTerminate = _getResponderConfig3.onResponderTerminate,\n      onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;\n\n      var allowTransfer = onResponderTerminationRequest != null && onResponderTerminationRequest(responderEvent);\n\n      if (allowTransfer) {\n\n        if (onResponderTerminate != null) {\n          responderEvent.currentTarget = currentNode;\n          onResponderTerminate(responderEvent);\n        }\n\n\n        if (onResponderGrant != null) {\n          onResponderGrant(responderEvent);\n        }\n\n        changeCurrentResponder(wantsResponder);\n      } else {\n\n        if (onResponderReject != null) {\n          onResponderReject(responderEvent);\n        }\n      }\n    }\n}\n\n\n\n\n\n\n\n\n\n\nvar documentEventsCapturePhase = ['blur', 'scroll'];\nvar documentEventsBubblePhase = [\n'mousedown', 'mousemove', 'mouseup', 'dragstart',\n'touchstart', 'touchmove', 'touchend', 'touchcancel',\n'contextmenu', 'select', 'selectionchange'];\n\nfunction attachListeners() {\n  if (_ExecutionEnvironment.canUseDOM && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\n\n\n\n\n\nfunction addNode(id, node, config) {\n  (0, _utils.setResponderId)(node, id);\n  responderListenersMap.set(id, config);\n}\n\n\n\n\n\nfunction removeNode(id) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\n\n\n\n\n\n\n\nfunction terminateResponder() {\n  var _currentResponder3 = currentResponder,\n  id = _currentResponder3.id,\n  node = _currentResponder3.node;\n\n  if (id != null && node != null) {\n    var _getResponderConfig4 = getResponderConfig(id),\n    onResponderTerminate = _getResponderConfig4.onResponderTerminate;\n\n    if (onResponderTerminate != null) {\n      var event = (0, _createResponderEvent.default)({});\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n\n    changeCurrentResponder(emptyResponder);\n  }\n\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\n\n\n\n\n\n\nfunction getResponderNode() {\n  return currentResponder.node;\n}","map":{"version":3,"sources":["/Users/makenzis/Desktop/renative-template-chat-refactor/renative-template-chat/node_modules/react-native-web/dist/cjs/hooks/useResponderEvents/ResponderSystem.js"],"names":["exports","__esModule","attachListeners","addNode","removeNode","terminateResponder","getResponderNode","_ExecutionEnvironment","require","_createResponderEvent","_interopRequireDefault","_ResponderEventTypes","_utils","_ResponderTouchHistoryStore","obj","default","emptyObject","startRegistration","bubbles","moveRegistration","scrollRegistration","shouldSetResponderEvents","touchstart","mousedown","touchmove","mousemove","scroll","emptyResponder","id","idPath","node","responderListenersMap","Map","isEmulatingMouseEvents","trackedTouchCount","currentResponder","changeCurrentResponder","responder","getResponderConfig","config","get","eventListener","domEvent","eventType","type","eventTarget","target","isStartEvent","isStartish","isPrimaryPointerDown","isMoveEvent","isMoveish","isEndEvent","isEndish","isScrollEvent","isScroll","isSelectionChangeEvent","isSelectionChange","responderEvent","touches","length","recordTouchTrack","nativeEvent","eventPaths","getResponderPaths","wasNegotiated","wantsResponder","currentResponderIdPath","eventIdPath","lowestCommonAncestor","getLowestCommonAncestor","indexOfLowestCommonAncestor","indexOf","index","slice","nodePath","findWantsResponder","attemptTransfer","_currentResponder","_getResponderConfig","onResponderStart","onResponderMove","onResponderEnd","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","cancelable","currentTarget","isTerminateEvent","isCancelish","window","contains","relatedTarget","hasValidSelection","isReleaseEvent","hasTargetTouches","shouldTerminate","shouldSetCallbacks","shouldSetCallbackCaptureName","shouldSetCallbackBubbleName","check","callbackName","shouldSetCallback","i","result","isPropagationStopped","_i","_id","_node","_result","_id2","_node2","_currentResponder2","currentId","currentNode","_getResponderConfig2","onResponderGrant","onResponderReject","dispatchConfig","registrationName","_getResponderConfig3","allowTransfer","documentEventsCapturePhase","documentEventsBubblePhase","canUseDOM","__reactResponderSystemActive","addEventListener","forEach","document","setResponderId","set","has","delete","_currentResponder3","_getResponderConfig4","event"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.attachListeners = attachListeners;\nexports.addNode = addNode;\nexports.removeNode = removeNode;\nexports.terminateResponder = terminateResponder;\nexports.getResponderNode = getResponderNode;\n\nvar _ExecutionEnvironment = require(\"fbjs/lib/ExecutionEnvironment\");\n\nvar _createResponderEvent = _interopRequireDefault(require(\"./createResponderEvent\"));\n\nvar _ResponderEventTypes = require(\"./ResponderEventTypes\");\n\nvar _utils = require(\"./utils\");\n\nvar _ResponderTouchHistoryStore = _interopRequireDefault(require(\"./ResponderTouchHistoryStore\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * RESPONDER EVENT SYSTEM\n *\n * A single, global \"interaction lock\" on views. For a view to be the \"responder\" means\n * that pointer interactions are exclusive to that view and none other. The \"interaction\n * lock\" can be transferred (only) to ancestors of the current \"responder\" as long as\n * pointers continue to be active.\n *\n * Responder being granted:\n *\n * A view can become the \"responder\" after the following events:\n *  * \"pointerdown\" (implemented using \"touchstart\", \"mousedown\")\n *  * \"pointermove\" (implemented using \"touchmove\", \"mousemove\")\n *  * \"scroll\" (while a pointer is down)\n *  * \"selectionchange\" (while a pointer is down)\n *\n * If nothing is already the \"responder\", the event propagates to (capture) and from\n * (bubble) the event target until a view returns `true` for\n * `on*ShouldSetResponder(Capture)`.\n *\n * If something is already the responder, the event propagates to (capture) and from\n * (bubble) the lowest common ancestor of the event target and the current \"responder\".\n * Then negotiation happens between the current \"responder\" and a view that wants to\n * become the \"responder\": see the timing diagram below.\n *\n * (NOTE: Scrolled views either automatically become the \"responder\" or release the\n * \"interaction lock\". A native scroll view that isn't built on top of the responder\n * system must result in the current \"responder\" being notified that it no longer has\n * the \"interaction lock\" - the native system has taken over.\n *\n * Responder being released:\n *\n * As soon as there are no more active pointers that *started* inside descendants\n * of the *current* \"responder\", an `onResponderRelease` event is dispatched to the\n * current \"responder\", and the responder lock is released.\n *\n * Typical sequence of events:\n *  * startShouldSetResponder\n *  * responderGrant/Reject\n *  * responderStart\n *  * responderMove\n *  * responderEnd\n *  * responderRelease\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +--------------+          |                            |\n     | onTouchStart |          |                            |\n     +------+-------+    none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | | onResponder            | |\n            +------------------->|    TerminationRequest  | |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | | onResponderTerminate   |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\nvar emptyObject = {};\n/* ------------ IMPLEMENTATION ------------ */\n\nvar startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {\n  bubbles: true\n}];\nvar moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {\n  bubbles: true\n}];\nvar scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {\n  bubbles: false\n}];\nvar shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\nvar emptyResponder = {\n  id: null,\n  idPath: null,\n  node: null\n};\nvar responderListenersMap = new Map();\nvar isEmulatingMouseEvents = false;\nvar trackedTouchCount = 0;\nvar currentResponder = {\n  id: null,\n  node: null,\n  idPath: null\n};\n\nfunction changeCurrentResponder(responder) {\n  currentResponder = responder;\n}\n\nfunction getResponderConfig(id) {\n  var config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\n/**\n * Process native events\n *\n * A single event listener is used to manage the responder system.\n * All pointers are tracked in the ResponderTouchHistoryStore. Native events\n * are interpreted in terms of the Responder System and checked to see if\n * the responder should be transferred. Each host node that is attached to\n * the Responder System has an ID, which is used to look up its associated\n * callbacks.\n */\n\n\nfunction eventListener(domEvent) {\n  var eventType = domEvent.type;\n  var eventTarget = domEvent.target;\n  /**\n   * Manage emulated events and early bailout.\n   * Since PointerEvent is not used yet (lack of support in older Safari), it's\n   * necessary to manually manage the mess of browser touch/mouse events.\n   * And bailout early for termination events when there is no active responder.\n   */\n  // Flag when browser may produce emulated events\n\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  } // Remove flag when browser will not produce emulated events\n\n\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  } // Ignore various events in particular circumstances\n\n\n  if ( // Ignore browser emulated mouse events\n  eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents || // Ignore mousemove if a mousedown didn't occur first\n  eventType === 'mousemove' && trackedTouchCount < 1) {\n    return;\n  } // Remove flag after emulated events are finished\n\n\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n\n    return;\n  }\n\n  var isStartEvent = (0, _ResponderEventTypes.isStartish)(eventType) && (0, _utils.isPrimaryPointerDown)(domEvent);\n  var isMoveEvent = (0, _ResponderEventTypes.isMoveish)(eventType);\n  var isEndEvent = (0, _ResponderEventTypes.isEndish)(eventType);\n  var isScrollEvent = (0, _ResponderEventTypes.isScroll)(eventType);\n  var isSelectionChangeEvent = (0, _ResponderEventTypes.isSelectionChange)(eventType);\n  var responderEvent = (0, _createResponderEvent.default)(domEvent);\n  /**\n   * Record the state of active pointers\n   */\n\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n\n    _ResponderTouchHistoryStore.default.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n  /**\n   * Responder System logic\n   */\n\n\n  var eventPaths = (0, _utils.getResponderPaths)(domEvent);\n  var wasNegotiated = false;\n  var wantsResponder; // If an event occured that might change the current responder...\n\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\n    // If there is already a responder, prune the event paths to the lowest common ancestor\n    // of the existing responder and deepest target of the event.\n    var currentResponderIdPath = currentResponder.idPath;\n    var eventIdPath = eventPaths.idPath;\n\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      var lowestCommonAncestor = (0, _utils.getLowestCommonAncestor)(currentResponderIdPath, eventIdPath);\n\n      if (lowestCommonAncestor != null) {\n        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor); // Skip the current responder so it doesn't receive unexpected \"shouldSet\" events.\n\n        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n\n    if (eventPaths != null) {\n      // If a node wants to become the responder, attempt to transfer.\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n\n      if (wantsResponder != null) {\n        // Sets responder if none exists, or negotates with existing responder.\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  } // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.\n\n\n  if (currentResponder.id != null && currentResponder.node != null) {\n    var _currentResponder = currentResponder,\n        id = _currentResponder.id,\n        node = _currentResponder.node;\n\n    var _getResponderConfig = getResponderConfig(id),\n        onResponderStart = _getResponderConfig.onResponderStart,\n        onResponderMove = _getResponderConfig.onResponderMove,\n        onResponderEnd = _getResponderConfig.onResponderEnd,\n        onResponderRelease = _getResponderConfig.onResponderRelease,\n        onResponderTerminate = _getResponderConfig.onResponderTerminate,\n        onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;\n\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node; // Start\n\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        onResponderStart(responderEvent);\n      }\n    } // Move\n    else if (isMoveEvent) {\n        if (onResponderMove != null) {\n          onResponderMove(responderEvent);\n        }\n      } else {\n        var isTerminateEvent = (0, _ResponderEventTypes.isCancelish)(eventType) || // native context menu\n        eventType === 'contextmenu' || // window blur\n        eventType === 'blur' && eventTarget === window || // responder (or ancestors) blur\n        eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node || // native scroll without using a pointer\n        isScrollEvent && trackedTouchCount === 0 || // native scroll on node that is parent of the responder (allow siblings to scroll)\n        isScrollEvent && eventTarget.contains(node) && eventTarget !== node || // native select/selectionchange on node\n        isSelectionChangeEvent && (0, _utils.hasValidSelection)(domEvent);\n        var isReleaseEvent = isEndEvent && !isTerminateEvent && !(0, _utils.hasTargetTouches)(node, domEvent.touches); // End\n\n        if (isEndEvent) {\n          if (onResponderEnd != null) {\n            onResponderEnd(responderEvent);\n          }\n        } // Release\n\n\n        if (isReleaseEvent) {\n          if (onResponderRelease != null) {\n            onResponderRelease(responderEvent);\n          }\n\n          changeCurrentResponder(emptyResponder);\n        } // Terminate\n\n\n        if (isTerminateEvent) {\n          var shouldTerminate = true; // Responders can still avoid termination but only for these events.\n\n          if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {\n            if (wasNegotiated || // Only call this function is it wasn't already called during negotiation.\n            onResponderTerminationRequest != null && onResponderTerminationRequest(responderEvent) === false) {\n              shouldTerminate = false;\n            }\n          }\n\n          if (shouldTerminate) {\n            if (onResponderTerminate != null) {\n              onResponderTerminate(responderEvent);\n            }\n\n            changeCurrentResponder(emptyResponder);\n            isEmulatingMouseEvents = false;\n            trackedTouchCount = 0;\n          }\n        }\n      }\n  }\n}\n/**\n * Walk the event path to/from the target node. At each node, stop and call the\n * relevant \"shouldSet\" functions for the given event type. If any of those functions\n * call \"stopPropagation\" on the event, stop searching for a responder.\n */\n\n\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type]; // for Flow\n\n  if (shouldSetCallbacks != null) {\n    var idPath = eventPaths.idPath,\n        nodePath = eventPaths.nodePath;\n    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    var bubbles = shouldSetCallbacks[2].bubbles;\n\n    var check = function check(id, node, callbackName) {\n      var config = getResponderConfig(id);\n      var shouldSetCallback = config[callbackName];\n\n      if (shouldSetCallback != null) {\n        if (shouldSetCallback(responderEvent) === true) {\n          return {\n            id: id,\n            node: node,\n            idPath: idPath\n          };\n        }\n      }\n    }; // capture\n\n\n    for (var i = idPath.length - 1; i >= 0; i--) {\n      var id = idPath[i];\n      var node = nodePath[i];\n      var result = check(id, node, shouldSetCallbackCaptureName);\n\n      if (result != null) {\n        return result;\n      }\n\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    } // bubble\n\n\n    if (bubbles) {\n      for (var _i = 0; _i < idPath.length; _i++) {\n        var _id = idPath[_i];\n        var _node = nodePath[_i];\n\n        var _result = check(_id, _node, shouldSetCallbackBubbleName);\n\n        if (_result != null) {\n          return _result;\n        }\n\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      var _id2 = idPath[0];\n      var _node2 = nodePath[0];\n      var target = domEvent.target;\n\n      if (target === _node2) {\n        return check(_id2, _node2, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\n/**\n * Attempt to transfer the responder.\n */\n\n\nfunction attemptTransfer(responderEvent, wantsResponder) {\n  var _currentResponder2 = currentResponder,\n      currentId = _currentResponder2.id,\n      currentNode = _currentResponder2.node;\n  var id = wantsResponder.id,\n      node = wantsResponder.node;\n\n  var _getResponderConfig2 = getResponderConfig(id),\n      onResponderGrant = _getResponderConfig2.onResponderGrant,\n      onResponderReject = _getResponderConfig2.onResponderReject;\n\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node; // Set responder\n\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n\n    changeCurrentResponder(wantsResponder);\n  } // Negotiate with current responder\n  else {\n      var _getResponderConfig3 = getResponderConfig(currentId),\n          onResponderTerminate = _getResponderConfig3.onResponderTerminate,\n          onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;\n\n      var allowTransfer = onResponderTerminationRequest != null && onResponderTerminationRequest(responderEvent);\n\n      if (allowTransfer) {\n        // Terminate existing responder\n        if (onResponderTerminate != null) {\n          responderEvent.currentTarget = currentNode;\n          onResponderTerminate(responderEvent);\n        } // Grant next responder\n\n\n        if (onResponderGrant != null) {\n          onResponderGrant(responderEvent);\n        }\n\n        changeCurrentResponder(wantsResponder);\n      } else {\n        // Reject responder request\n        if (onResponderReject != null) {\n          onResponderReject(responderEvent);\n        }\n      }\n    }\n}\n/* ------------ PUBLIC API ------------ */\n\n/**\n * Attach Listeners\n *\n * Use native events as ReactDOM doesn't have a non-plugin API to implement\n * this system.\n */\n\n\nvar documentEventsCapturePhase = ['blur', 'scroll'];\nvar documentEventsBubblePhase = [// mouse\n'mousedown', 'mousemove', 'mouseup', 'dragstart', // touch\n'touchstart', 'touchmove', 'touchend', 'touchcancel', // other\n'contextmenu', 'select', 'selectionchange'];\n\nfunction attachListeners() {\n  if (_ExecutionEnvironment.canUseDOM && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\n/**\n * Register a node with the ResponderSystem.\n */\n\n\nfunction addNode(id, node, config) {\n  (0, _utils.setResponderId)(node, id);\n  responderListenersMap.set(id, config);\n}\n/**\n * Unregister a node with the ResponderSystem.\n */\n\n\nfunction removeNode(id) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\n/**\n * Allow the current responder to be terminated from within components to support\n * more complex requirements, such as use with other React libraries for working\n * with scroll views, input views, etc.\n */\n\n\nfunction terminateResponder() {\n  var _currentResponder3 = currentResponder,\n      id = _currentResponder3.id,\n      node = _currentResponder3.node;\n\n  if (id != null && node != null) {\n    var _getResponderConfig4 = getResponderConfig(id),\n        onResponderTerminate = _getResponderConfig4.onResponderTerminate;\n\n    if (onResponderTerminate != null) {\n      var event = (0, _createResponderEvent.default)({});\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n\n    changeCurrentResponder(emptyResponder);\n  }\n\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\n/**\n * Allow unit tests to inspect the current responder in the system.\n * FOR TESTING ONLY.\n */\n\n\nfunction getResponderNode() {\n  return currentResponder.node;\n}"]},"metadata":{},"sourceType":"script"}